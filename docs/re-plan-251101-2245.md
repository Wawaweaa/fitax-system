【单一沟通包：请按此计划执行并在每个步骤产出“日志+改动说明+验收结果”。若某一步需要我手动跑命令，请在输出里明确给出命令。】

目标（WX 视频号链路端到端跑通，真实样本，本地可验收，可迁移生产）
- 以本地单机为目标：上传 → 处理(/api/process) → Worker 消费 → 有效视图更新 → 导出/预览。
- 彻底移除“本地调试简化版”遗留；统一上传记录契约；本地用 inmemory 队列，禁用 Upstash 以免跨境网络干扰。
- 输出：脚本化冒烟、自描述日志、可复制的部署与环境说明；为生产切国内 Redis 预留配置位。

——— 立即生效的技术决策 ———
1) 本地与预览：`QUEUE_DRIVER=inmemory`（不依赖外网）。生产：改国内 Redis（阿里/腾讯/华为）。  
2) 构建：强制使用 webpack（Turbopack 在 duckdb 链有坑）。  
3) 合约：统一 `registerUpload` 记录结构，所有调用以 `uploadId(ULP-*)` 为唯一入口；`/api/process` 严格按 `uploadId` 查记录。

——— 步骤 0｜基线分支 & 运行方式（避免“Working… esc to interrupt”假卡）———
a. 新建分支：`git checkout -b fix/wxvideo-e2e`  
b. 后台启动：  
   - Worker：`cd frontend && nohup npm run worker:dev > worker.log 2>&1 & echo $! > .worker.pid && sleep 1 && ps -p $(cat .worker.pid) -o pid,etimes,command`  
   - Web：`cd frontend && npm run dev`（前台跑 / 或者后台：`nohup npm run dev > dev.log 2>&1 & echo $! > .dev.pid`）  
   产出：把 `ps` 行、`tail -n 50 worker.log`、`dev.log` 关键行贴出。

——— 步骤 1｜统一上传记录契约（核心修复）———
【目标】修正 `/api/upload` 的落盘逻辑与返回体，恢复/实现 `registerUpload()` 为唯一事实来源；`/api/process` 仅按 `uploadId` 取记录，杜绝“简化结构”。
    1. 约定结构（写入 `frontend/data/uploads.json` 或 DB；以 JSON 数组为例）：  
   ```json
   {
     "id": "ULP-<uuid>",
     "user_id": "test-user-001",
     "platform": "wechat_video",
     "file_type": "settlement",
     "objectKey": "raw/user_id=<..>/platform=<..>/file_type=<..>/uploaded_at=<ts>/demo.xlsx",
     "contentHash": "<sha256>",
     "uploaded_at": 1730xxxxxxx
   }

    2.	/app/api/upload/route.ts 必须：
	•	校验 multipart、platform、文件类型；
	•	计算 contentHash；将文件写入本地 STORAGE_LOCAL_DIR 下规范化路径得到 objectKey；
	•	调 registerUpload(record) 将上面 JSON 追加写入 uploads.json；
	•	return 200，body 至少包含：
    { "files": [{ "uploadId": "ULP-...", "contenthash": "...", "fileType": "settlement", "originalFilename": "..." }], "data": { "files": [{ /* 同上 */ }] } }

    3.	/app/api/process/route.ts 必须：
	•	解析 userId；从请求体读取 uploadId；
	•	通过 getUploadRecord(uploadId) 读取 uploads.json（或 DB）；查不到 → 404 {message:"结算文件上传记录不存在: <id>"}；
	•	找到后按 objectKey 拉取源文件并进入 S0/S1/merge/parquet/有效视图更新；排队/入队逻辑如设计。

【验收】
	•	运行上传脚本（可用你仓内 scripts/test-upload-process.ts 或我方提供 heredoc），打印响应 JSON，确认 files[0].uploadId 为 ULP-* 且 uploads.json 出现完整记录；
	•	直接 POST /api/process（或脚本二段式）以该 uploadId 请求，不再 404；若仍失败，请同时贴出 worker.log 与接口响应。

——— 步骤 2｜本地用 inmemory 队列，确认 Worker 能消费 ———
	1.	.env.local（frontend/）建议临时内容：
    QUEUE_DRIVER=inmemory
    STORAGE_DRIVER=local
    STORAGE_LOCAL_DIR=./data/storage
    DATABASE_DRIVER=duckdb
    DEFAULT_USER_ID=test-user-001
    MAX_UPLOAD_MB=50
    ALLOWED_EXT=.xlsx,.csv
    SIGN_URL_TTL_SEC=3600
   请不要再读取 Upstash；若代码分支仍有 Upstash 初始化，请在本地路径分支里绕开。

   	2.	重启 Worker（后台）并 tail -n 80 worker.log 观察：出现“收到作业/处理完成”字样。
    【验收】上传→process 后，worker.log 有“拉取/处理/完成”的线索；若无，回贴最近 100 行。

——— 步骤 3｜构建与配置修正（避免导出阶段再踩坑）———
	1.	Next 仅用 webpack：npm run dev 保持 --webpack；
	2.	next.config.mjs：
	•	移除/迁移无效键：把 experimental.serverComponentsExternalPackages 迁到 serverExternalPackages 或先删除；移除 experimental.turbo 相关；
	•	暂将 duckdb 标记 external（避免 @mapbox/node-pre-gyp 的 .html 资源导致打包报错）：
    /** @type {import('next').NextConfig} */
    const nextConfig = {
        webpack: (config) => {
            config.externals = config.externals || [];
            config.externals.push({ duckdb: 'commonjs2 duckdb' });
            return config;
        },
    };
export default nextConfig;

【验收】npm run dev 启动无红色报错；若仍有 invalid key 警告，贴出完整 next.config.mjs 做一次性修正。

——— 步骤 4｜端到端冒烟脚本（纳入提测必跑）———
	1.	scripts/smoke-upload.ts：读取真实 demo xlsx，POST /api/upload，打印 uploadId 与 uploads.json 中对应记录（校验 objectKey 存在）。
	2.	scripts/smoke-process.ts：携带 uploadId 调 /api/process，轮询/等待完成，打印关键统计与输出路径（effective/parquet）。
	3.	一键脚本：npm run smoke:wxvideo（顺序执行 1 → 2）。
【验收】在干净环境连跑 2 次均通过；控制台打印包含：uploadId=ULP-*、process=200、effective rows/agg 概要。

——— 步骤 5｜导出/预览验证———
	•	以 UI 操作“处理并预览/导出”，确认前端展示为真实数据（不再是 default-user 模拟），导出可下载成功。
【验收】提供页面截图（带 summary/告警/汇总片段）+ 成功下载的文件名与落盘路径。

——— 步骤 6｜交付与回收———
	•	提交变更：
	•	upload/route.ts、process/route.ts、lib/uploads.ts（或等价实现）、next.config.mjs、脚本与 .env.local.example。
	•	附 MIGRATION.md：如何从旧“简化版”迁至统一契约（含 uploads.json 备份清理命令：
cp data/uploads.json "data/uploads.backup.$(date +%s).json" && jq '[.[] | select(.id != null)]' data/uploads.json > data/uploads.cleaned.json && mv data/uploads.cleaned.json data/uploads.json）。
	•	产出日志包：worker.log 片段、接口响应 JSON、uploads.json 相关片段（打码 token/隐私）。

——— 生产落位（供后续跟进，不在本次提交中完成）———
	•	国内云：Next（next start）、Worker（PM2/Systemd）同机/同 VPC；托管 Redis（内网地址）；对象存储（OSS/COS）；DuckDB/Parquet 持久卷。
	•	.env：切到 QUEUE_DRIVER=redis 并给出 REDIS_URL 等；前后端均不再依赖境外服务。
	•	保持与本地一致的上传记录契约与请求路径，冒烟脚本指向生产域做“小样本验收”。

——— 请在执行中遵守 ———
	•	不要再次启用 Upstash；本地仅用 inmemory；
	•	Worker 一律后台启动并交付 .worker.pid 与 worker.log，避免 CLI 假卡；
	•	每个步骤产出“改动清单 + 命令 + 日志 + 验收结果”；如需我本机配合执行，请在输出中给出可直接粘贴的命令（含多行 heredoc）。

完成后，请一次性回传：①改动说明（文件清单/核心代码位置）；②三段关键日志（上传响应、process 响应、worker.log 消费痕迹）；③npm run smoke:wxvideo 的完整输出；④UI 预览与导出截图。若中途被阻断（例如老数据污染），请按“问题→原因→最小复现→建议修复”的格式反馈，并附带可执行命令。

