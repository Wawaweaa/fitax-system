下面是一份可直接一键粘贴覆盖re-plan-251101-2245.md 的更新版（已把你刚给的“国内服务接口、禁止 Upstash、本地只用 inmemory、Vercel 仅作早期前端预览”等补充点合并进来，并保持“可执行 + 可验收”的结构）。你只需把整段贴回原文件即可。

# Fitax-System 重新规划（WX 视频号先行）— 国内服务接口版（2025-11-02）

> 本文档用于**替换**现有的 re-plan-251101-2245.md。目标：以“微信视频号链路端到端跑通”为里程碑，统一上传记录契约，移除一切境外依赖；本地稳定可验收，staging/prod 完整落地国内云。

---

## 最高优先变更声明（必须立即执行）
1. **线上/预发布/Staging/Prod 全部使用国内服务商**：Redis 选阿里云/腾讯云/华为云托管版；对象存储选 OSS/COS；CDN/HTTPS/监控均走国内。  
2. **Upstash 一律禁用并移出代码路径**（含环境变量、初始化分支、依赖），**本地开发仅允许 `QUEUE_DRIVER=inmemory`**，从根源上消除跨境网络变量。  
3. **Vercel 仅用于“早期前端预览/评审”**：不得承载真实用户与大文件上传。  
4. **统一“上传记录（ULP-*) 为唯一事实来源”的接口契约**：`/api/process` 只接受 `uploadId`，一切处理从上传记录拉取 `objectKey` 进入 S0/S1/merge/parquet/有效视图更新。  

---

## 完成判据（Definition of Done）
- **本机端到端闭环**：上传 → 处理（/api/process）→ Worker 消费 → 有效视图 → 导出/预览，**连续跑通 2 次且结果一致**。  
- `/api/upload` 返回 `files[0].uploadId=ULP-*`；`frontend/data/uploads.json` 中存在对应记录（含 `objectKey`、`contentHash`、`uploaded_at`）。  
- `worker.log` 出现“拉取作业/处理完成”闭环日志；**UI 预览为真实数据**（非 default-user 模拟），导出文件可打开、命名含 `platform_yyyyMM_timestamp.xlsx`。  
- **一键冒烟**：`npm run smoke:wxvideo` 输出包含 `uploadId=ULP-* / process=200 / effective rows` 概要。  
- **文档与产物**：提交 `MIGRATION.md / RUNBOOK.md / TROUBLESHOOTING.md / .env.local.example（中文注释）`，并附日志包（接口响应 JSON、worker.log、uploads.json 片段、预览/导出截图）。  

---

## 环境与配置矩阵（全部国内方案）
- **local**：  
  - `QUEUE_DRIVER=inmemory`；`STORAGE_DRIVER=local`；DuckDB/Parquet 本地目录；`DEFAULT_USER_ID=test-user-001`。  
- **staging（国内云）**：  
  - `QUEUE_DRIVER=redis`；`REDIS_URL=内网地址`；`STORAGE_DRIVER=oss|cos`（必要时先 `local` 绑定磁盘卷）；CDN 国内；测试子域（可未备案）。  
- **prod（国内云）**：  
  - 同 staging，备案/证书/CDN 完成后切流；**队列/存储/计算组件全部在 VPC 内**。  
- **`.env.local.example`（示例，中文注释）**  

QUEUE_DRIVER=inmemory
STORAGE_DRIVER=local
STORAGE_LOCAL_DIR=./data/storage
DATABASE_DRIVER=duckdb
DEFAULT_USER_ID=test-user-001
MAX_UPLOAD_MB=50
ALLOWED_EXT=.xlsx,.csv
SIGN_URL_TTL_SEC=3600

> staging/prod 把 `QUEUE_DRIVER=redis` 并提供 `REDIS_URL`；严禁出现 Upstash 字段。

---

## 步骤 0｜基线分支 & 运行方式（避免 CLI “假卡”）
- 新建分支：`git checkout -b fix/wxvideo-e2e`  
- 后台启动（或前台 dev 亦可；**必须产出日志**）：  
- Worker：  
  ```bash
  cd frontend
  nohup npm run worker:dev > worker.log 2>&1 & echo $! > .worker.pid
  sleep 1
  ps -p $(cat .worker.pid) -o pid,etimes,command
  tail -n 50 worker.log
  ```
- Web：  
  ```bash
  cd frontend
  npm run dev   # 或后台：nohup npm run dev > dev.log 2>&1 & echo $! > .dev.pid && tail -n 50 dev.log
  ```
- 产出：`ps` 行、`worker.log` 片段、`dev.log` 关键行。

---

步骤 1｜统一上传记录契约（核心修复）
**目标**：修正 `/api/upload` 落盘逻辑与返回体；恢复/实现 `registerUpload(record)`；`/api/process` 仅按 `uploadId` 取记录，杜绝“简化结构”。

1. **约定结构**（写入 `frontend/data/uploads.json` 或 DB；以 JSON 数组为例）
```json
{
"id": "ULP-<uuid>",
"user_id": "test-user-001",
"platform": "wechat_video",
"file_type": "settlement",
"objectKey": "raw/user_id=<..>/platform=<..>/file_type=<..>/year=2025/month=08/uploaded_at=<ts>/demo.xlsx",
"contentHash": "<sha256>",
"uploaded_at": 1730xxxxxxx
}

2.	/app/api/upload/route.ts 必须

	•	校验 multipart、platform、文件类型；
	•	计算 contentHash；把文件写入 STORAGE_LOCAL_DIR 下规范化路径得到 objectKey；
	•	调 registerUpload(record) 追加写入 uploads.json；
	•	return 200，body 同时在 files 与 data.files 返回：

{
  "files": [{
    "uploadId": "ULP-...",
    "contenthash": "...",
    "fileType": "settlement",
    "originalFilename": "..."
  }],
  "data": { "files": [ { /* 同上 */ } ] }
}

3.	/app/api/process/route.ts 必须

	•	解析 userId；从请求体读取 uploadId；
	•	getUploadRecord(uploadId) 查 uploads.json（或 DB）；查不到 → 404 {message:"结算文件上传记录不存在: <id>"}；
	•	找到后按 objectKey 拉取源文件并进入 S0/S1/merge/parquet/有效视图更新；排队/入队按设计。

验收
	•	运行上传脚本（仓内 scripts/test-upload-process.ts 或 heredoc），打印响应 JSON，确认 files[0].uploadId=ULP-* 且 uploads.json 出现完整记录；
	•	以该 uploadId 请求 /api/process（脚本二段式或 Postman），不再 404；若失败，同时贴出 worker.log 与接口响应。

⸻

步骤 2｜本地用 inmemory 队列，确认 Worker 能消费
	•	.env.local（frontend/） 建议临时值（同“环境矩阵”示例），不要再读取 Upstash；若代码还留 Upstash 初始化，在本地路径显式绕开/注释。
	•	重启 Worker（后台）并 tail -n 80 worker.log：出现“收到作业/处理完成”字样。
	•	验收：上传→process 后，worker.log 有“拉取/处理/完成”的线索；若无，贴最近 100 行回检。

⸻

步骤 3｜构建与配置修正（避免导出阶段再踩坑）
	1.	Next 开发强制使用 webpack：npm run dev 保持 --webpack。
	2.	next.config.mjs 修正：
	•	移除/迁移无效键：把 experimental.serverComponentsExternalPackages 迁到 serverExternalPackages 或先删除；移除 experimental.turbo；
	•	暂把 duckdb 标记 external（规避 @mapbox/node-pre-gyp 内置 .html）：

/** @type {import('next').NextConfig} */
const nextConfig = {
  webpack: (config) => {
    config.externals = config.externals || [];
    config.externals.push({ duckdb: 'commonjs2 duckdb' });
    return config;
  },
};
export default nextConfig;


	•	验收：npm run dev 启动无红色报错；若仍有 invalid key 警告，贴完整 next.config.mjs 一次性修正。

⸻

步骤 4｜端到端冒烟脚本（必须纳入提测）
	•	scripts/smoke-upload.ts：读取真实 demo xlsx，POST /api/upload，打印 uploadId 与 uploads.json 中对应记录（校验 objectKey 存在）。
	•	scripts/smoke-process.ts：携带 uploadId 调 /api/process，轮询/等待完成，打印关键统计与输出路径（effective/parquet）。
	•	一键脚本：npm run smoke:wxvideo 顺序执行上面两步。
	•	验收：在干净环境连跑 2 次均通过；控制台打印包含 uploadId=ULP-* / process=200 / effective rows/agg 概要。

⸻

步骤 5｜导出/预览验证
	•	用 UI 操作“处理并预览/导出”，确认前端展示为真实数据（不再是 default-user 模拟），导出可下载成功。
	•	验收：提供页面截图（带 summary/告警/汇总片段） + 成功下载文件名与落盘路径。

⸻

步骤 6｜交付与回收
	•	提交变更：upload/route.ts、process/route.ts、lib/uploads.ts（或等价实现）、next.config.mjs、脚本与 .env.local.example；
	•	附 MIGRATION.md：如何从旧“简化版”迁到统一契约（含 uploads.json 备份/清理命令）：

cp data/uploads.json "data/uploads.backup.$(date +%s).json" || true
# 若本机无 jq: brew install jq
jq '[.[] | select(.id != null)]' data/uploads.json > data/uploads.cleaned.json && mv data/uploads.cleaned.json data/uploads.json


	•	产出日志包：worker.log 片段、接口响应 JSON、uploads.json 相关片段（打码隐私）、预览与导出截图。

⸻

作业生命周期与失败恢复
	•	状态：queued → reserved → processing → done/failed；预留 reserve_ttl / max_retries / retry_backoff。
	•	失败恢复：fail 进入失败集合，可 retry；提供“重放最近 ULP”的命令样例（写入 RUNBOOK）。

⸻

日志与观测（国内落地）
	•	所有接口与 Worker 日志携带 request_id / upload_id，统一结构化输出；
	•	指标：uploads/min、queue_depth、job_latency_ms(p50/p95)、export_success_rate；
	•	本地排查：tail -f worker.log | grep <ULP>；线上预留 Prometheus/云监控规则（后补实现）。

⸻

失败与降级策略
	•	Redis 不可达：local 允许自动降级到 inmemory；staging/prod 禁止自动降级，明确报错；
	•	DuckDB/磁盘写失败（容量不足）：返回可诊断错误并引导清理 data/；
	•	文件过大/非法后缀：返回 413/400，UI 友好提示；
	•	CSV 编码/行尾容错：S0 统一处理 GBK/CRLF；
	•	结算归属：明确“对账月”口径，避免跨月误归档；
	•	中文文件名安全：safeJoin + 白名单后缀。

⸻

前端 UX 协议
	•	上传成功提示“已登记(ULP-…)，可处理”；“处理并预览”在队列处理中禁用并显示进度；
	•	错误映射：404=“未找到上传记录/请先上传并记下 uploadId”，413=“文件过大（>50MB）”。

⸻

安全与合规
	•	现阶段暂用 x-user-id，后续切换鉴权（JWT/Session）；日志屏蔽 PII/文件名（mask 规则）；
	•	上传文件保留与清理策略：默认 30 天；提供 npm run clean:retention（RUNBOOK 说明）。

⸻

发布与回滚（国内云）
	•	分支：fix/wxvideo-e2e → staging → main；每步产出日志包（接口响应/worker.log/截图）；
	•	启动：next build && next start；Worker 用 PM2/Systemd/Docker 常驻，与 Web 同 VPC；
	•	回滚：上个标签镜像，配置不变；RUNBOOK 给出 start/stop/restart/status 与回滚命令。

⸻

国内云上线前置检查清单
	•	Redis（内网）连通：redis-cli/HTTP 健康检查；
	•	OSS/COS 读写验证脚本；
	•	域名/证书/CDN/备案状态核验；
	•	预设域名策略：prod 使用国内解析；preview 子域临时指向 Vercel 仅做前端评审。

⸻

Next 配置与构建注意
	•	强制 webpack：package.json 的 dev 保留 --webpack；
	•	next.config.mjs：移除 experimental.* 旧键；必要时将 duckdb 标记 external；
	•	多锁文件提示：短期可接受，后续统一只保留 npm 锁；engines: node ">=22.2 <23"。

⸻

RUNBOOK 片段（落仓 /RUNBOOK.md）

启动（本地）

cd frontend
nohup npm run worker:dev > worker.log 2>&1 & echo $! > .worker.pid
nohup npm run dev --webpack > dev.log 2>&1 & echo $! > .dev.pid
tail -n 50 worker.log; tail -n 20 dev.log

停止

kill $(cat .worker.pid) 2>/dev/null || true
kill $(cat .dev.pid) 2>/dev/null || true
pkill -f "next dev" 2>/dev/null || true

清理后重跑

cp data/uploads.json "data/uploads.backup.$(date +%s).json" || true
# 若本机无 jq: brew install jq
jq '[.[] | select(.id != null)]' data/uploads.json > data/uploads.cleaned.json && mv data/uploads.cleaned.json data/uploads.json
rm -rf data/effective data/parquet && mkdir -p data/effective data/parquet
npm run smoke:wxvideo


⸻

脚本化验收（必须纳入提测流水线）
	•	scripts/smoke-upload.ts：真实 demo xlsx → POST /api/upload → 打印 uploadId 与 uploads.json 匹配记录（含 objectKey）。
	•	scripts/smoke-process.ts：带 uploadId 调 /api/process → 轮询至完成 → 打印 effective/agg 概要与输出路径。
	•	聚合为 npm run smoke:wxvideo；干净环境连跑 2 次均通过。
	•	若报错，按**“问题→原因→最小复现→修复建议→可执行命令”**格式反馈，并附接口响应与 worker.log 片段。

⸻

立即执行清单（WX 视频号链路）
	1.	合并统一上传记录契约（/api/upload 与 /api/process 对齐），避免 process 404；
	2.	本地强制 QUEUE_DRIVER=inmemory；移除 Upstash 代码路径与变量读取（如仍存在，注释并标注“仅历史演示”）；
	3.	完成一次端到端闭环并提交日志包 + 截图；随后提交“国内云部署最小清单”（Node/PM2 + 内网 Redis + OSS/COS 可选）与执行脚本。

备注
	•	多行命令同时提供一行版备选（必要时在 PR 里补充）；
	•	macOS 默认无 jq，请在文档显式提示 brew install jq；
	•	如需我本机协助，请在更新中给出可直接粘贴执行的命令（含默认参数）。

本更新稿是在你现有的 re-plan 文档基础上做的整合与替换：原文已包含“立即生效技术决策、统一上传记录契约、冒烟脚本、生产落位”等骨架，我已将“**全部使用国内服务接口/禁用 Upstash/Vercel 仅作早期预览**”等新增约束并入对应章节，并把 **DoD/环境矩阵/RUNBOOK/验收** 统一成可执行格式（参考你原稿中“步骤 0/1/4/6 结构”的写法）。参见原稿中“立即生效的技术决策、步骤 0、步骤 1、步骤 4/5/6、生产落位”等章节骨架以保证衔接与可读性。  [oai_citation:0‡re-plan-251101-2245.md](sediment://file_00000000c25c7230b1988fd2135900e7)  [oai_citation:1‡re-plan-251101-2245.md](sediment://file_00000000d92471f5be53599d18d1b735)



［补丁：生产环境队列与上传方案更正（以本文件为准）］
1.	队列从 Redis 调整为 MNS（Simple Message Queue）
	•	原 re-plan 中对 staging/prod 的“QUEUE_DRIVER=redis + REDIS_URL”描述，在生产落地时以 MNS 取代：
	•	QUEUE_DRIVER=mns
	•	MNS_ENDPOINT=https://<mns-endpoint>
	•	MNS_QUEUE_NAME=fitax-jobs
	•	本地开发仍保持 QUEUE_DRIVER=inmemory，禁用一切境外依赖（Upstash 保持禁止）。
2.	上传方式在生产采用 OSS 的 STS 直传
	•	新增后端签发接口：/api/oss/sts（或 /api/oss/policy），前端拿临时凭证直传 OSS（支持分片/断点续传）。
	•	POST /api/upload 在 生产 环境主要承担上传登记：接收 objectKey + contentHash 元数据并写入 uploads.json/DB，返回 uploadId=ULP-*；
	•	本地开发继续保留传统 multipart 直传到 STORAGE_LOCAL_DIR 的路径，随后同样登记上传记录。
	•	两条路径统一到同一份“上传记录契约”（uploadId / objectKey / contentHash / uploaded_at …），/api/process 依旧只接受 uploadId，通过记录里的 objectKey 取源文件进入 S0/S1/merge/Parquet/有效视图更新。

除以上两点具体化/替换外，其余 re-plan 内容（禁用 Upstash、Vercel 仅作前端预览、本地只用 inmemory、统一 ULP 契约、DoD/冒烟/Runbook/回滚 等）与本生产部署方案一致，无需更改。





